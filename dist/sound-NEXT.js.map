{"version":3,"names":[],"mappings":"","sources":["sound-NEXT.js"],"sourcesContent":["/**\n * @license SoundJS\n * Visit http://createjs.com for documentation, updates and examples.\n *\n * Copyright (c) 2017 gskinner.com, inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\nvar createjs = function(exports) {\n  \"use strict\";\n  var classCallCheck = function(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\")\n    }\n  };\n  var createClass = function() {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor)\n      }\n    }\n    return function(Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor\n    }\n  }();\n  var inherits = function(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass)\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass\n  };\n  var possibleConstructorReturn = function(self, call) {\n    if (!self) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\")\n    }\n    return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self\n  };\n  /**\n   * A collection of classes that are shared across the CreateJS libraries.\n   * Classes required by a library are compiled with that library.\n   *\n   * @module CreateJS\n   * @main CreateJS\n   */\n  /**\n   * Contains properties and methods shared by all events for use with {{#crossLink \"EventDispatcher\"}}{{/crossLink}}.\n   * Note that Event objects are often reused, so you should never\n   * rely on an event object's state outside of the call stack it was received in.\n   *\n   * @class Event\n   * @module CreateJS\n   */\n  var Event = function() {\n    // constructor:\n    /**\n     * @param {String} type The event type.\n     * @param {Boolean} [bubbles=false] Indicates whether the event will bubble through the display list.\n     * @param {Boolean} [cancelable=false] Indicates whether the default behaviour of this event can be cancelled.\n     * @constructor\n     */\n    function Event(type) {\n      var bubbles = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var cancelable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      classCallCheck(this, Event);\n      /**\n       * The type of event.\n       * @property type\n       * @type String\n       */\n      this.type = type;\n      /**\n       * The object that generated an event.\n       * @property target\n       * @type Object\n       * @default null\n       * @readonly\n       */\n      this.target = null;\n      /**\n       * The current target that a bubbling event is being dispatched from. For non-bubbling events, this will\n       * always be the same as target. For example, if childObj.parent = parentObj, and a bubbling event\n       * is generated from childObj, then a listener on parentObj would receive the event with\n       * target=childObj (the original target) and currentTarget=parentObj (where the listener was added).\n       * @property currentTarget\n       * @type Object\n       * @default null\n       * @readonly\n       */\n      this.currentTarget = null;\n      /**\n       * For bubbling events, this indicates the current event phase:<OL>\n       * \t<LI> capture phase: starting from the top parent to the target</LI>\n       * \t<LI> at target phase: currently being dispatched from the target</LI>\n       * \t<LI> bubbling phase: from the target to the top parent</LI>\n       * </OL>\n       * @property eventPhase\n       * @type Number\n       * @default 0\n       * @readonly\n       */\n      this.eventPhase = 0;\n      /**\n       * Indicates whether the event will bubble through the display list.\n       * @property bubbles\n       * @type Boolean\n       * @default false\n       * @readonly\n       */\n      this.bubbles = bubbles;\n      /**\n       * Indicates whether the default behaviour of this event can be cancelled via\n       * {{#crossLink \"Event/preventDefault\"}}{{/crossLink}}. This is set via the Event constructor.\n       * @property cancelable\n       * @type Boolean\n       * @default false\n       * @readonly\n       */\n      this.cancelable = cancelable;\n      /**\n       * The epoch time at which this event was created.\n       * @property timeStamp\n       * @type Number\n       * @default 0\n       * @readonly\n       */\n      this.timeStamp = (new Date).getTime();\n      /**\n       * Indicates if {{#crossLink \"Event/preventDefault\"}}{{/crossLink}} has been called\n       * on this event.\n       * @property defaultPrevented\n       * @type Boolean\n       * @default false\n       * @readonly\n       */\n      this.defaultPrevented = false;\n      /**\n       * Indicates if {{#crossLink \"Event/stopPropagation\"}}{{/crossLink}} or\n       * {{#crossLink \"Event/stopImmediatePropagation\"}}{{/crossLink}} has been called on this event.\n       * @property propagationStopped\n       * @type Boolean\n       * @default false\n       * @readonly\n       */\n      this.propagationStopped = false;\n      /**\n       * Indicates if {{#crossLink \"Event/stopImmediatePropagation\"}}{{/crossLink}} has been called\n       * on this event.\n       * @property immediatePropagationStopped\n       * @type Boolean\n       * @default false\n       * @readonly\n       */\n      this.immediatePropagationStopped = false;\n      /**\n       * Indicates if {{#crossLink \"Event/remove\"}}{{/crossLink}} has been called on this event.\n       * @property removed\n       * @type Boolean\n       * @default false\n       * @readonly\n       */\n      this.removed = false\n    }\n    // public methods:\n    /**\n     * Sets {{#crossLink \"Event/defaultPrevented\"}}{{/crossLink}} to true if the event is cancelable.\n     * Mirrors the DOM level 2 event standard. In general, cancelable events that have `preventDefault()` called will\n     * cancel the default behaviour associated with the event.\n     * @method preventDefault\n     */\n    Event.prototype.preventDefault = function preventDefault() {\n      this.defaultPrevented = this.cancelable\n    };\n    /**\n     * Sets {{#crossLink \"Event/propagationStopped\"}}{{/crossLink}} to true.\n     * Mirrors the DOM event standard.\n     * @method stopPropagation\n     */\n    Event.prototype.stopPropagation = function stopPropagation() {\n      this.propagationStopped = true\n    };\n    /**\n     * Sets {{#crossLink \"Event/propagationStopped\"}}{{/crossLink}} and\n     * {{#crossLink \"Event/immediatePropagationStopped\"}}{{/crossLink}} to true.\n     * Mirrors the DOM event standard.\n     * @method stopImmediatePropagation\n     */\n    Event.prototype.stopImmediatePropagation = function stopImmediatePropagation() {\n      this.immediatePropagationStopped = this.propagationStopped = true\n    };\n    /**\n     * Causes the active listener to be removed via removeEventListener();\n     *\n     * \t\tmyBtn.addEventListener(\"click\", function(evt) {\n     * \t\t\t// do stuff...\n     * \t\t\tevt.remove(); // removes this listener.\n     * \t\t});\n     *\n     * @method remove\n     */\n    Event.prototype.remove = function remove() {\n      this.removed = true\n    };\n    /**\n     * Returns a clone of the Event instance.\n     * @method clone\n     * @return {Event} a clone of the Event instance.\n     */\n    Event.prototype.clone = function clone() {\n      var event = new Event(this.type, this.bubbles, this.cancelable);\n      for (var n in this) {\n        if (this.hasOwnProperty(n)) {\n          event[n] = this[n]\n        }\n      }\n      return event\n    };\n    /**\n     * Provides a chainable shortcut method for setting a number of properties on the instance.\n     *\n     * @method set\n     * @param {Object} props A generic object containing properties to copy to the instance.\n     * @return {Event} Returns the instance the method is called on (useful for chaining calls.)\n     * @chainable\n     */\n    Event.prototype.set = function set(props) {\n      for (var n in props) {\n        this[n] = props[n]\n      }\n      return this\n    };\n    /**\n     * Returns a string representation of this object.\n     * @method toString\n     * @return {String} a string representation of the instance.\n     */\n    Event.prototype.toString = function toString() {\n      return \"[\" + this.constructor.name + \" (type=\" + this.type + \")]\"\n    };\n    return Event\n  }();\n  /**\n   * EventDispatcher provides methods for managing queues of event listeners and dispatching events.\n   *\n   * You can either extend EventDispatcher or mix its methods into an existing prototype or instance by using the\n   * EventDispatcher {{#crossLink \"EventDispatcher/initialize\"}}{{/crossLink}} method.\n   *\n   * Together with the CreateJS Event class, EventDispatcher provides an extended event model that is based on the\n   * DOM Level 2 event model, including addEventListener, removeEventListener, and dispatchEvent. It supports\n   * bubbling / capture, preventDefault, stopPropagation, stopImmediatePropagation, and handleEvent.\n   *\n   * EventDispatcher also exposes a {{#crossLink \"EventDispatcher/on\"}}{{/crossLink}} method, which makes it easier\n   * to create scoped listeners, listeners that only run once, and listeners with associated arbitrary data. The\n   * {{#crossLink \"EventDispatcher/off\"}}{{/crossLink}} method is merely an alias to\n   * {{#crossLink \"EventDispatcher/removeEventListener\"}}{{/crossLink}}.\n   *\n   * Another addition to the DOM Level 2 model is the {{#crossLink \"EventDispatcher/removeAllEventListeners\"}}{{/crossLink}}\n   * method, which can be used to listeners for all events, or listeners for a specific event. The Event object also\n   * includes a {{#crossLink \"Event/remove\"}}{{/crossLink}} method which removes the active listener.\n   *\n   * <h4>Example</h4>\n   * Add EventDispatcher capabilities to the \"MyClass\" class.\n   *\n   *      EventDispatcher.initialize(MyClass.prototype);\n   *\n   * Add an event (see {{#crossLink \"EventDispatcher/addEventListener\"}}{{/crossLink}}).\n   *\n   *      instance.addEventListener(\"eventName\", handlerMethod);\n   *      function handlerMethod(event) {\n   *          console.log(event.target + \" Was Clicked\");\n   *      }\n   *\n   * <b>Maintaining proper scope</b><br />\n   * Scope (ie. \"this\") can be be a challenge with events. Using the {{#crossLink \"EventDispatcher/on\"}}{{/crossLink}}\n   * method to subscribe to events simplifies this.\n   *\n   *      instance.addEventListener(\"click\", function(event) {\n   *          console.log(instance == this); // false, scope is ambiguous.\n   *      });\n   *\n   *      instance.on(\"click\", function(event) {\n   *          console.log(instance == this); // true, \"on\" uses dispatcher scope by default.\n   *      });\n   *\n   * If you want to use addEventListener instead, you may want to use function.bind() or a similar proxy to manage scope.\n   *\n   *\n   * @class EventDispatcher\n   * @module CreateJS\n   */\n  var EventDispatcher = function() {\n    // static methods:\n    /**\n     * Static initializer to mix EventDispatcher methods into a target object or prototype.\n     *\n     * \t\tEventDispatcher.initialize(MyClass.prototype); // add to the prototype of the class\n     * \t\tEventDispatcher.initialize(myObject); // add to a specific instance\n     *\n     * @method initialize\n     * @static\n     * @param {Object} target The target object to inject EventDispatcher methods into. This can be an instance or a\n     * prototype.\n     */\n    EventDispatcher.initialize = function initialize(target) {\n      var p = EventDispatcher.prototype;\n      target.addEventListener = p.addEventListener;\n      target.on = p.on;\n      target.removeEventListener = target.off = p.removeEventListener;\n      target.removeAllEventListeners = p.removeAllEventListeners;\n      target.hasEventListener = p.hasEventListener;\n      target.dispatchEvent = p.dispatchEvent;\n      target._dispatchEvent = p._dispatchEvent;\n      target.willTrigger = p.willTrigger\n    };\n    // constructor:\n    /**\n     * @constructor\n     */\n    function EventDispatcher() {\n      classCallCheck(this, EventDispatcher);\n      /**\n       * @protected\n       * @property _listeners\n       * @type Object\n       */\n      this._listeners = null;\n      /**\n       * @protected\n       * @property _captureListeners\n       * @type Object\n       */\n      this._captureListeners = null\n    }\n    // public methods:\n    /**\n     * Adds the specified event listener. Note that adding multiple listeners to the same function will result in\n     * multiple callbacks getting fired.\n     *\n     * <h4>Example</h4>\n     *\n     *      displayObject.addEventListener(\"click\", handleClick);\n     *      function handleClick(event) {\n     *         // Click happened.\n     *      }\n     *\n     * @method addEventListener\n     * @param {String} type The string type of the event.\n     * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when\n     * the event is dispatched.\n     * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n     * @return {Function | Object} Returns the listener for chaining or assignment.\n     */\n    EventDispatcher.prototype.addEventListener = function addEventListener(type, listener, useCapture) {\n      var listeners = void 0;\n      if (useCapture) {\n        listeners = this._captureListeners = this._captureListeners || {}\n      } else {\n        listeners = this._listeners = this._listeners || {}\n      }\n      var arr = listeners[type];\n      if (arr) {\n        this.removeEventListener(type, listener, useCapture)\n      }\n      arr = listeners[type]; // remove may have deleted the array\n      if (!arr) {\n        listeners[type] = [listener]\n      } else {\n        arr.push(listener)\n      }\n      return listener\n    };\n    /**\n     * A shortcut method for using addEventListener that makes it easier to specify an execution scope, have a listener\n     * only run once, associate arbitrary data with the listener, and remove the listener.\n     *\n     * This method works by creating an anonymous wrapper function and subscribing it with addEventListener.\n     * The wrapper function is returned for use with `removeEventListener` (or `off`).\n     *\n     * <b>IMPORTANT:</b> To remove a listener added with `on`, you must pass in the returned wrapper function as the listener, or use\n     * {{#crossLink \"Event/remove\"}}{{/crossLink}}. Likewise, each time you call `on` a NEW wrapper function is subscribed, so multiple calls\n     * to `on` with the same params will create multiple listeners.\n     *\n     * <h4>Example</h4>\n     *\n     * \t\tvar listener = myBtn.on(\"click\", handleClick, null, false, {count:3});\n     * \t\tfunction handleClick(evt, data) {\n     * \t\t\tdata.count -= 1;\n     * \t\t\tconsole.log(this == myBtn); // true - scope defaults to the dispatcher\n     * \t\t\tif (data.count == 0) {\n     * \t\t\t\talert(\"clicked 3 times!\");\n     * \t\t\t\tmyBtn.off(\"click\", listener);\n     * \t\t\t\t// alternately: evt.remove();\n     * \t\t\t}\n     * \t\t}\n     *\n     * @method on\n     * @param {String} type The string type of the event.\n     * @param {Function | Object} listener An object with a handleEvent method, or a function that will be called when\n     * the event is dispatched.\n     * @param {Object} [scope] The scope to execute the listener in. Defaults to the dispatcher/currentTarget for function listeners, and to the listener itself for object listeners (ie. using handleEvent).\n     * @param {Boolean} [once=false] If true, the listener will remove itself after the first time it is triggered.\n     * @param {*} [data] Arbitrary data that will be included as the second parameter when the listener is called.\n     * @param {Boolean} [useCapture=false] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n     * @return {Function} Returns the anonymous function that was created and assigned as the listener. This is needed to remove the listener later using .removeEventListener.\n     */\n    EventDispatcher.prototype.on = function on(type, listener) {\n      var scope = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var once = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var data = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n      var useCapture = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n      if (listener.handleEvent) {\n        scope = scope || listener;\n        listener = listener.handleEvent\n      }\n      scope = scope || this;\n      return this.addEventListener(type, function(evt) {\n        listener.call(scope, evt, data);\n        once && evt.remove()\n      }, useCapture)\n    };\n    /**\n     * Removes the specified event listener.\n     *\n     * <b>Important Note:</b> that you must pass the exact function reference used when the event was added. If a proxy\n     * function, or function closure is used as the callback, the proxy/closure reference must be used - a new proxy or\n     * closure will not work.\n     *\n     * <h4>Example</h4>\n     *\n     *      displayObject.removeEventListener(\"click\", handleClick);\n     *\n     * @method removeEventListener\n     * @param {String} type The string type of the event.\n     * @param {Function | Object} listener The listener function or object.\n     * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n     */\n    EventDispatcher.prototype.removeEventListener = function removeEventListener(type, listener, useCapture) {\n      var listeners = useCapture ? this._captureListeners : this._listeners;\n      if (!listeners) {\n        return\n      }\n      var arr = listeners[type];\n      if (!arr) {\n        return\n      }\n      var l = arr.length;\n      for (var i = 0; i < l; i++) {\n        if (arr[i] == listener) {\n          if (l == 1) {\n            delete listeners[type]\n          } else {\n            arr.splice(i, 1)\n          }\n          break\n        }\n      }\n    };\n    /**\n     * A shortcut to the removeEventListener method, with the same parameters and return value. This is a companion to the\n     * .on method.\n     *\n     * <b>IMPORTANT:</b> To remove a listener added with `on`, you must pass in the returned wrapper function as the listener. See\n     * {{#crossLink \"EventDispatcher/on\"}}{{/crossLink}} for an example.\n     *\n     * @method off\n     * @param {String} type The string type of the event.\n     * @param {Function | Object} listener The listener function or object.\n     * @param {Boolean} [useCapture] For events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase.\n     */\n    EventDispatcher.prototype.off = function off(type, listener, useCapture) {\n      this.removeEventListener(type, listener, useCapture)\n    };\n    /**\n     * Removes all listeners for the specified type, or all listeners of all types.\n     *\n     * <h4>Example</h4>\n     *\n     *      // Remove all listeners\n     *      displayObject.removeAllEventListeners();\n     *\n     *      // Remove all click listeners\n     *      displayObject.removeAllEventListeners(\"click\");\n     *\n     * @method removeAllEventListeners\n     * @param {String} [type] The string type of the event. If omitted, all listeners for all types will be removed.\n     */\n    EventDispatcher.prototype.removeAllEventListeners = function removeAllEventListeners(type) {\n      if (!type) {\n        this._listeners = this._captureListeners = null\n      } else {\n        if (this._listeners) {\n          delete this._listeners[type]\n        }\n        if (this._captureListeners) {\n          delete this._captureListeners[type]\n        }\n      }\n    };\n    /**\n     * Dispatches the specified event to all listeners.\n     *\n     * <h4>Example</h4>\n     *\n     *      // Use a string event\n     *      this.dispatchEvent(\"complete\");\n     *\n     *      // Use an Event instance\n     *      var event = new createjs.Event(\"progress\");\n     *      this.dispatchEvent(event);\n     *\n     * @method dispatchEvent\n     * @param {Object | String | Event} eventObj An object with a \"type\" property, or a string type.\n     * While a generic object will work, it is recommended to use a CreateJS Event instance. If a string is used,\n     * dispatchEvent will construct an Event instance if necessary with the specified type. This latter approach can\n     * be used to avoid event object instantiation for non-bubbling events that may not have any listeners.\n     * @param {Boolean} [bubbles] Specifies the `bubbles` value when a string was passed to eventObj.\n     * @param {Boolean} [cancelable] Specifies the `cancelable` value when a string was passed to eventObj.\n     * @return {Boolean} Returns false if `preventDefault()` was called on a cancelable event, true otherwise.\n     */\n    EventDispatcher.prototype.dispatchEvent = function dispatchEvent(eventObj) {\n      var bubbles = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var cancelable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      if (typeof eventObj == \"string\") {\n        // skip everything if there's no listeners and it doesn't bubble:\n        var listeners = this._listeners;\n        if (!bubbles && (!listeners || !listeners[eventObj])) {\n          return true\n        }\n        eventObj = new Event(eventObj, bubbles, cancelable)\n      } else if (eventObj.target && eventObj.clone) {\n        // redispatching an active event object, so clone it:\n        eventObj = eventObj.clone()\n      }\n      // TODO: it would be nice to eliminate this. Maybe in favour of evtObj instanceof Event? Or !!evtObj.createEvent\n      try {\n        eventObj.target = this\n      } catch (e) {} // try/catch allows redispatching of native events\n      if (!eventObj.bubbles || !this.parent) {\n        this._dispatchEvent(eventObj, 2)\n      } else {\n        var top = this,\n          i = void 0;\n        var list = [top];\n        while (top.parent) {\n          list.push(top = top.parent)\n        }\n        var l = list.length;\n        // capture & atTarget\n        for (i = l - 1; i >= 0 && !eventObj.propagationStopped; i--) {\n          list[i]._dispatchEvent(eventObj, 1 + (i == 0))\n        }\n        // bubbling\n        for (i = 1; i < l && !eventObj.propagationStopped; i++) {\n          list[i]._dispatchEvent(eventObj, 3)\n        }\n      }\n      return !eventObj.defaultPrevented\n    };\n    /**\n     * Indicates whether there is at least one listener for the specified event type.\n     * @method hasEventListener\n     * @param {String} type The string type of the event.\n     * @return {Boolean} Returns true if there is at least one listener for the specified event.\n     */\n    EventDispatcher.prototype.hasEventListener = function hasEventListener(type) {\n      var listeners = this._listeners,\n        captureListeners = this._captureListeners;\n      return !!(listeners && listeners[type] || captureListeners && captureListeners[type])\n    };\n    /**\n     * Indicates whether there is at least one listener for the specified event type on this object or any of its\n     * ancestors (parent, parent's parent, etc). A return value of true indicates that if a bubbling event of the\n     * specified type is dispatched from this object, it will trigger at least one listener.\n     *\n     * This is similar to {{#crossLink \"EventDispatcher/hasEventListener\"}}{{/crossLink}}, but it searches the entire\n     * event flow for a listener, not just this object.\n     * @method willTrigger\n     * @param {String} type The string type of the event.\n     * @return {Boolean} Returns `true` if there is at least one listener for the specified event.\n     */\n    EventDispatcher.prototype.willTrigger = function willTrigger(type) {\n      var o = this;\n      while (o) {\n        if (o.hasEventListener(type)) {\n          return true\n        }\n        o = o.parent\n      }\n      return false\n    };\n    /**\n     * @method toString\n     * @return {String} a string representation of the instance.\n     */\n    EventDispatcher.prototype.toString = function toString() {\n      return \"[EventDispatcher]\"\n    };\n    // private methods:\n    /**\n     * @method _dispatchEvent\n     * @param {Object | String | Event} eventObj\n     * @param {Object} eventPhase\n     * @protected\n     */\n    EventDispatcher.prototype._dispatchEvent = function _dispatchEvent(eventObj, eventPhase) {\n      var listeners = eventPhase == 1 ? this._captureListeners : this._listeners;\n      var l = void 0;\n      if (eventObj && listeners) {\n        var arr = listeners[eventObj.type];\n        if (!arr || !(l = arr.length)) {\n          return\n        }\n        try {\n          eventObj.currentTarget = this\n        } catch (e) {}\n        try {\n          eventObj.eventPhase = eventPhase\n        } catch (e) {}\n        eventObj.removed = false;\n        arr = arr.slice(); // to avoid issues with items being removed or added during the dispatch\n        for (var i = 0; i < l && !eventObj.immediatePropagationStopped; i++) {\n          var o = arr[i];\n          if (o.handleEvent) {\n            o.handleEvent(eventObj)\n          } else {\n            o(eventObj)\n          }\n          if (eventObj.removed) {\n            this.off(eventObj.type, o, eventPhase == 1);\n            eventObj.removed = false\n          }\n        }\n      }\n    };\n    return EventDispatcher\n  }();\n  /**\n   * The Ticker provides a centralized tick or heartbeat broadcast at a set interval. Listeners can subscribe to the tick\n   * event to be notified when a set time interval has elapsed.\n   *\n   * Note that the interval that the tick event is called is a target interval, and may be broadcast at a slower interval\n   * when under high CPU load. The Ticker class uses a static interface (ex. `Ticker.framerate = 30;`) and\n   * can not be instantiated.\n   *\n   * <h4>Example</h4>\n   *\n   *      createjs.Ticker.addEventListener(\"tick\", handleTick);\n   *      function handleTick(event) {\n   *          // Actions carried out each tick (aka frame)\n   *          if (!event.paused) {\n   *              // Actions carried out when the Ticker is not paused.\n   *          }\n   *      }\n   *\n   * @class TickerAPI\n   * @extends EventDispatcher\n   * @module CreateJS\n   */\n  var TickerAPI = function(_EventDispatcher) {\n    inherits(TickerAPI, _EventDispatcher);\n    // constructor:\n    /**\n     * @param name {String} The name assigned to this instance.\n     * @constructor\n     * TODO-ES6: Pass timingMode, maxDelta, paused values as instantiation arguments?\n     */\n    function TickerAPI(name) {\n      classCallCheck(this, TickerAPI);\n      // public properties:\n      /**\n       * The name of this instance.\n       * @property name\n       * @type {String}\n       */\n      var _this = possibleConstructorReturn(this, _EventDispatcher.call(this));\n      _this.name = name;\n      /**\n       * Specifies the timing api (setTimeout or requestAnimationFrame) and mode to use. See\n       * {{#crossLink \"Ticker/TIMEOUT\"}}{{/crossLink}}, {{#crossLink \"Ticker/RAF\"}}{{/crossLink}}, and\n       * {{#crossLink \"Ticker/RAF_SYNCHED\"}}{{/crossLink}} for mode details.\n       * @property timingMode\n       * @type {String}\n       * @default Ticker.TIMEOUT\n       */\n      _this.timingMode = TickerAPI.TIMEOUT;\n      /**\n       * Specifies a maximum value for the delta property in the tick event object. This is useful when building time\n       * based animations and systems to prevent issues caused by large time gaps caused by background tabs, system sleep,\n       * alert dialogs, or other blocking routines. Double the expected frame duration is often an effective value\n       * (ex. maxDelta=50 when running at 40fps).\n       *\n       * This does not impact any other values (ex. time, runTime, etc), so you may experience issues if you enable maxDelta\n       * when using both delta and other values.\n       *\n       * If 0, there is no maximum.\n       * @property maxDelta\n       * @type {number}\n       * @default 0\n       */\n      _this.maxDelta = 0;\n      /**\n       * When the ticker is paused, all listeners will still receive a tick event, but the <code>paused</code> property\n       * of the event will be `true`. Also, while paused the `runTime` will not increase. See {{#crossLink \"Ticker/tick:event\"}}{{/crossLink}},\n       * {{#crossLink \"Ticker/getTime\"}}{{/crossLink}}, and {{#crossLink \"Ticker/getEventTime\"}}{{/crossLink}} for more\n       * info.\n       *\n       * <h4>Example</h4>\n       *\n       *      createjs.Ticker.addEventListener(\"tick\", handleTick);\n       *      createjs.Ticker.paused = true;\n       *      function handleTick(event) {\n       *          console.log(event.paused,\n       *          \tcreatejs.Ticker.getTime(false),\n       *          \tcreatejs.Ticker.getTime(true));\n       *      }\n       *\n       * @property paused\n       * @type {Boolean}\n       * @default false\n       */\n      _this.paused = false;\n      // private properties:\n      /**\n       * @property _inited\n       * @type {Boolean}\n       * @protected\n       */\n      _this._inited = false;\n      /**\n       * @property _startTime\n       * @type {Number}\n       * @protected\n       */\n      _this._startTime = 0;\n      /**\n       * @property _pausedTime\n       * @type {Number}\n       * @protected\n       */\n      _this._pausedTime = 0;\n      /**\n       * The number of ticks that have passed\n       * @property _ticks\n       * @type {Number}\n       * @protected\n       */\n      _this._ticks = 0;\n      /**\n       * The number of ticks that have passed while Ticker has been paused\n       * @property _pausedTicks\n       * @type {Number}\n       * @protected\n       */\n      _this._pausedTicks = 0;\n      /**\n       * @property _interval\n       * @type {Number}\n       * @protected\n       */\n      _this._interval = 50;\n      /**\n       * @property _lastTime\n       * @type {Number}\n       * @protected\n       */\n      _this._lastTime = 0;\n      /**\n       * @property _times\n       * @type {Array}\n       * @protected\n       */\n      _this._times = null;\n      /**\n       * @property _tickTimes\n       * @type {Array}\n       * @protected\n       */\n      _this._tickTimes = null;\n      /**\n       * Stores the timeout or requestAnimationFrame id.\n       * @property _timerId\n       * @type {Number}\n       * @protected\n       */\n      _this._timerId = null;\n      /**\n       * True if currently using requestAnimationFrame, false if using setTimeout. This may be different than timingMode\n       * if that property changed and a tick hasn't fired.\n       * @property _raf\n       * @type {Boolean}\n       * @protected\n       */\n      _this._raf = true;\n      return _this\n    }\n    // accessor properties:\n    /**\n     * Indicates the target time (in milliseconds) between ticks. Default is 50 (20 FPS).\n     * Note that actual time between ticks may be more than specified depending on CPU load.\n     * This property is ignored if the ticker is using the `RAF` timing mode.\n     * @property interval\n     * @static\n     * @type {Number}\n     */\n    // public methods:\n    /**\n     * Call createjs.Ticker.create() to get a new TickerAPI instance.\n     * It is not initalized by default and its ticks are not synched with any other instance.\n     *\n     * @param name {String} The name given to the new instance.\n     * @method create\n     * @return {TickerAPI} A new TickerAPI instance.\n     */\n    TickerAPI.prototype.create = function create(name) {\n      return new TickerAPI(name)\n    };\n    /**\n     * Starts the tick. This is called automatically when the first listener is added.\n     * @method init\n     */\n    TickerAPI.prototype.init = function init() {\n      if (this._inited) {\n        return\n      }\n      this._inited = true;\n      this._times = [];\n      this._tickTimes = [];\n      this._startTime = this._getTime();\n      this._times.push(this._lastTime = 0);\n      this._setupTick()\n    };\n    /**\n     * Stops the Ticker and removes all listeners. Use init() to restart the Ticker.\n     * @method reset\n     */\n    TickerAPI.prototype.reset = function reset() {\n      if (this._raf) {\n        var f = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame;\n        f && f(this._timerId)\n      } else {\n        clearTimeout(this._timerId)\n      }\n      this.removeAllEventListeners(\"tick\");\n      this._timerId = this._times = this._tickTimes = null;\n      this._startTime = this._lastTime = this._ticks = 0;\n      this._inited = false\n    };\n    /**\n     * Init the Ticker instance if it hasn't been already.\n     * Docced in superclass.\n     */\n    TickerAPI.prototype.addEventListener = function addEventListener(type, listener, useCapture) {\n      !this._inited && this.init();\n      return _EventDispatcher.prototype.addEventListener.call(this, type, listener, useCapture)\n    };\n    /**\n     * Returns the average time spent within a tick. This can vary significantly from the value provided by getMeasuredFPS\n     * because it only measures the time spent within the tick execution stack.\n     *\n     * Example 1: With a target FPS of 20, getMeasuredFPS() returns 20fps, which indicates an average of 50ms between\n     * the end of one tick and the end of the next. However, getMeasuredTickTime() returns 15ms. This indicates that\n     * there may be up to 35ms of \"idle\" time between the end of one tick and the start of the next.\n     *\n     * Example 2: With a target FPS of 30, getFPS() returns 10fps, which indicates an average of 100ms between the end of\n     * one tick and the end of the next. However, getMeasuredTickTime() returns 20ms. This would indicate that something\n     * other than the tick is using ~80ms (another script, DOM rendering, etc).\n     * @method getMeasuredTickTime\n     * @param {Number} [ticks] The number of previous ticks over which to measure the average time spent in a tick.\n     * Defaults to the number of ticks per second. To get only the last tick's time, pass in 1.\n     * @return {Number} The average time spent in a tick in milliseconds.\n     */\n    TickerAPI.prototype.getMeasuredTickTime = function getMeasuredTickTime(ticks) {\n      var times = this._tickTimes;\n      if (!times || times.length < 1) {\n        return -1\n      }\n      // by default, calculate average for the past ~1 second:\n      ticks = Math.min(times.length, ticks || this.framerate | 0);\n      var ttl = times.reduce(function(a, b) {\n        return a + b\n      }, 0);\n      return ttl / ticks\n    };\n    /**\n     * Returns the actual frames / ticks per second.\n     * @method getMeasuredFPS\n     * @param {Number} [ticks] The number of previous ticks over which to measure the actual frames / ticks per second.\n     * Defaults to the number of ticks per second.\n     * @return {Number} The actual frames / ticks per second. Depending on performance, this may differ\n     * from the target frames per second.\n     */\n    TickerAPI.prototype.getMeasuredFPS = function getMeasuredFPS(ticks) {\n      var times = this._times;\n      if (!times || times.length < 2) {\n        return -1\n      }\n      // by default, calculate fps for the past ~1 second:\n      ticks = Math.min(times.length - 1, ticks || this.framerate | 0);\n      return 1e3 / ((times[0] - times[ticks]) / ticks)\n    };\n    /**\n     * Returns the number of milliseconds that have elapsed since Ticker was initialized via {{#crossLink \"Ticker/init\"}}.\n     * Returns -1 if Ticker has not been initialized. For example, you could use\n     * this in a time synchronized animation to determine the exact amount of time that has elapsed.\n     * @method getTime\n     * @param {Boolean} [runTime=false] If true only time elapsed while Ticker was not paused will be returned.\n     * If false, the value returned will be total time elapsed since the first tick event listener was added.\n     * @return {Number} Number of milliseconds that have elapsed since Ticker was initialized or -1.\n     */\n    TickerAPI.prototype.getTime = function getTime() {\n      var runTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      return this._startTime ? this._getTime() - (runTime ? this._pausedTime : 0) : -1\n    };\n    /**\n     * Similar to the {{#crossLink \"Ticker/getTime\"}}{{/crossLink}} method, but returns the time on the most recent {{#crossLink \"Ticker/tick:event\"}}{{/crossLink}}\n     * event object.\n     * @method getEventTime\n     * @param runTime {Boolean} [runTime=false] If true, the runTime property will be returned instead of time.\n     * @returns {number} The time or runTime property from the most recent tick event or -1.\n     */\n    TickerAPI.prototype.getEventTime = function getEventTime() {\n      var runTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      return this._startTime ? (this._lastTime || this._startTime) - (runTime ? this._pausedTime : 0) : -1\n    };\n    /**\n     * Returns the number of ticks that have been broadcast by Ticker.\n     * @method getTicks\n     * @param {Boolean} [pauseable=false] Indicates whether to include ticks that would have been broadcast\n     * while Ticker was paused. If true only tick events broadcast while Ticker is not paused will be returned.\n     * If false, tick events that would have been broadcast while Ticker was paused will be included in the return\n     * value.\n     * @return {Number} of ticks that have been broadcast.\n     */\n    TickerAPI.prototype.getTicks = function getTicks() {\n      var pauseable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      return this._ticks - (pauseable ? this._pausedTicks : 0)\n    };\n    // private methods:\n    /**\n     * @method _handleSynch\n     * @protected\n     */\n    TickerAPI.prototype._handleSynch = function _handleSynch() {\n      this._timerId = null;\n      this._setupTick();\n      // run if enough time has elapsed, with a little bit of flexibility to be early:\n      if (this._getTime() - this._lastTime >= (this._interval - 1) * .97) {\n        this._tick()\n      }\n    };\n    /**\n     * @method _handleRAF\n     * @protected\n     */\n    TickerAPI.prototype._handleRAF = function _handleRAF() {\n      this._timerId = null;\n      this._setupTick();\n      this._tick()\n    };\n    /**\n     * @method _handleTimeout\n     * @protected\n     */\n    TickerAPI.prototype._handleTimeout = function _handleTimeout() {\n      this._timerId = null;\n      this._setupTick();\n      this._tick()\n    };\n    /**\n     * @method _setupTick\n     * @protected\n     */\n    TickerAPI.prototype._setupTick = function _setupTick() {\n      if (this._timerId != null) {\n        return\n      } // avoid duplicates\n      var mode = this.timingMode || this._raf && TickerAPI.RAF; // TODO-ES6: Verify that this is desired, since Ticker.useRAF was removed.\n      if (mode == TickerAPI.RAF_SYNCHED || mode == TickerAPI.RAF) {\n        var f = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame;\n        if (f) {\n          this._timerId = f(mode == TickerAPI.RAF ? this._handleRAF.bind(this) : this._handleSynch.bind(this));\n          this._raf = true;\n          return\n        }\n      }\n      this._raf = false;\n      this._timerId = setTimeout(this._handleTimeout.bind(this), this._interval)\n    };\n    /**\n     * @method _tick\n     * @protected\n     */\n    TickerAPI.prototype._tick = function _tick() {\n      var paused = this.paused;\n      var time = this._getTime();\n      var elapsedTime = time - this._lastTime;\n      this._lastTime = time;\n      this._ticks++;\n      if (paused) {\n        this._pausedTicks++;\n        this._pausedTime += elapsedTime\n      }\n      if (this.hasEventListener(\"tick\")) {\n        var event = new Event(\"tick\");\n        var maxDelta = this.maxDelta;\n        event.delta = maxDelta && elapsedTime > maxDelta ? maxDelta : elapsedTime;\n        event.paused = paused;\n        event.time = time;\n        event.runTime = time - this._pausedTime;\n        this.dispatchEvent(event)\n      }\n      this._tickTimes.unshift(this._getTime() - time);\n      while (this._tickTimes.length > 100) {\n        this._tickTimes.pop()\n      }\n      this._times.unshift(time);\n      while (this._times.length > 100) {\n        this._times.pop()\n      }\n    };\n    /**\n     * @method _getTime\n     * @protected\n     */\n    TickerAPI.prototype._getTime = function _getTime() {\n      var now = window.performance.now;\n      return (now && now.call(performance) || (new Date).getTime()) - this._startTime\n    };\n    createClass(TickerAPI, [{\n      key: \"interval\",\n      get: function get() {\n        return this._interval\n      },\n      set: function set(interval) {\n        this._interval = interval;\n        if (!this._inited) {\n          return\n        }\n        this._setupTick()\n      }\n    }, {\n      key: \"framerate\",\n      get: function get() {\n        return 1e3 / this._interval\n      },\n      set: function set(fps) {\n        this.interval = 1e3 / fps\n      }\n    }]);\n    return TickerAPI\n  }(EventDispatcher);\n  // constants:\n  /**\n   * In this mode, Ticker uses the requestAnimationFrame API, but attempts to synch the ticks to target framerate. It\n   * uses a simple heuristic that compares the time of the RAF return to the target time for the current frame and\n   * dispatches the tick when the time is within a certain threshold.\n   *\n   * This mode has a higher variance for time between frames than {{#crossLink \"Ticker/TIMEOUT:property\"}}{{/crossLink}},\n   * but does not require that content be time based as with {{#crossLink \"Ticker/RAF:property\"}}{{/crossLink}} while\n   * gaining the benefits of that API (screen synch, background throttling).\n   *\n   * Variance is usually lowest for framerates that are a divisor of the RAF frequency. This is usually 60, so\n   * framerates of 10, 12, 15, 20, and 30 work well.\n   *\n   * Falls back to {{#crossLink \"Ticker/TIMEOUT:property\"}}{{/crossLink}} if the requestAnimationFrame API is not\n   * supported.\n   * @property RAF_SYNCHED\n   * @static\n   * @type {String}\n   * @default \"synched\"\n   * @readonly\n   */\n  TickerAPI.RAF_SYNCHED = \"synched\";\n  /**\n   * In this mode, Ticker passes through the requestAnimationFrame heartbeat, ignoring the target framerate completely.\n   * Because requestAnimationFrame frequency is not deterministic, any content using this mode should be time based.\n   * You can leverage {{#crossLink \"Ticker/getTime\"}}{{/crossLink}} and the {{#crossLink \"Ticker/tick:event\"}}{{/crossLink}}\n   * event object's \"delta\" properties to make this easier.\n   *\n   * Falls back on {{#crossLink \"Ticker/TIMEOUT:property\"}}{{/crossLink}} if the requestAnimationFrame API is not\n   * supported.\n   * @property RAF\n   * @static\n   * @type {String}\n   * @default \"raf\"\n   * @readonly\n   */\n  TickerAPI.RAF = \"raf\";\n  /**\n   * In this mode, Ticker uses the setTimeout API. This provides predictable, adaptive frame timing, but does not\n   * provide the benefits of requestAnimationFrame (screen synch, background throttling).\n   * @property TIMEOUT\n   * @static\n   * @type {String}\n   * @default \"timeout\"\n   * @readonly\n   */\n  TickerAPI.TIMEOUT = \"timeout\";\n  // events:\n  /**\n   * Dispatched each tick. The event will be dispatched to each listener even when the Ticker has been paused using\n   * {{#crossLink \"Ticker/setPaused\"}}{{/crossLink}}.\n   *\n   * <h4>Example</h4>\n   *\n   *      createjs.Ticker.addEventListener(\"tick\", handleTick);\n   *      function handleTick(event) {\n   *          console.log(\"Paused:\", event.paused, event.delta);\n   *      }\n   *\n   * @event tick\n   * @param {Object} target The object that dispatched the event.\n   * @param {String} type The event type.\n   * @param {Boolean} paused Indicates whether the ticker is currently paused.\n   * @param {Number} delta The time elapsed in ms since the last tick.\n   * @param {Number} time The total time in ms since Ticker was initialized.\n   * @param {Number} runTime The total time in ms that Ticker was not paused since it was initialized. For example,\n   * \tyou could determine the amount of time that the Ticker has been paused since initialization with `time-runTime`.\n   * @since 0.6.0\n   */\n  /**\n   * The Ticker object is a singleton instance of the TickerAPI class.\n   * See the {{#crossLink \"TickerAPI\"}}{{/crossLink}} documentation for its usage.\n   * @class Ticker\n   * @static\n   * @module CreateJS\n   */\n  var Ticker = new TickerAPI(\"createjs.global\");\n  var Sample = function(_EventDispatcher) {\n    inherits(Sample, _EventDispatcher);\n    createClass(Sample, [{\n      key: \"volume\",\n      set: function set(val) {\n        this.volumeNode.gain.value = val\n      },\n      get: function get() {\n        return this.volumeNode.gain.value\n      }\n    }]);\n\n    function Sample(url) {\n      classCallCheck(this, Sample);\n      var _this = possibleConstructorReturn(this, _EventDispatcher.call(this));\n      var ctx = Sound.context;\n      _this.outputNode = _this.volumeNode = ctx.createGain();\n      _this.fxBus = ctx.createGain();\n      _this.fxBus.connect(_this.outputNode); // TODO: Manage effects chain.\n      _this.playbacks = [];\n      _this.audioBuffer = null;\n      _this._playbackRequested = false;\n      if (url) {\n        _this.loadAudio(url)\n      }\n      Sound._rootGroup.add(_this);\n      return _this\n    }\n    Sample.prototype.play = function play() {\n      if (!this.audioBuffer) {\n        this._playbackRequested = true;\n        return null\n      } else {\n        return this._play()\n      }\n    };\n    Sample.prototype._play = function _play() {\n      var pb = new Playback(this.audioBuffer);\n      this.playbacks.push(pb);\n      pb.outputNode.connect(this.fxBus);\n      return pb\n    };\n    Sample.prototype.loadAudio = function loadAudio(url) {\n      var request = new XMLHttpRequest;\n      request.open(\"GET\", url, true);\n      request.responseType = \"arraybuffer\";\n      request.onload = this.handleAudioLoaded.bind(this);\n      request.send()\n    };\n    Sample.prototype.handleAudioLoaded = function handleAudioLoaded(loadEvent) {\n      var ctx = Sound.context;\n      var result = loadEvent.target.response;\n      ctx.decodeAudioData(result, this.handleAudioDecoded.bind(this), this.handleAudioDecodeError.bind(this))\n    };\n    Sample.prototype.handleAudioDecoded = function handleAudioDecoded(buffer) {\n      this.audioBuffer = buffer;\n      if (this._playbackRequested) {\n        this._play()\n      }\n    };\n    Sample.prototype.handleAudioDecodeError = function handleAudioDecodeError(e) {\n      console.log(\"Error decoding audio data.\")\n    };\n    return Sample\n  }(EventDispatcher);\n  var Group = function() {\n    function Group() {\n      var parent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Sound._rootGroup;\n      classCallCheck(this, Group);\n      var ctx = Sound.context;\n      this.outputNode = this.volumeNode = ctx.createGain();\n      this.inputNode = ctx.createGain();\n      this.fxBus = ctx.createGain();\n      this.inputNode.connect(this.fxBus);\n      this.fxBus.connect(this.outputNode); // TODO: Manage effects chain.\n      this.samples = [];\n      this.subgroups = [];\n      if (parent) {\n        parent.add(this)\n      }\n    }\n    Group.prototype.add = function add(groupOrSample) {\n      if (groupOrSample instanceof Group) {\n        this._addGroup(groupOrSample)\n      } else if (groupOrSample instanceof Sample) {\n        this._addSample(groupOrSample)\n      }\n    };\n    Group.prototype._addGroup = function _addGroup(subgroup) {\n      this.subgroups.push(subgroup);\n      subgroup.outputNode.connect(this.inputNode)\n    };\n    Group.prototype._addSample = function _addSample(sample) {\n      this.samples.push(sample);\n      sample.outputNode.connect(this.fxBus)\n    };\n    return Group\n  }();\n  var Sound = function() {\n    function Sound() {\n      classCallCheck(this, Sound)\n    }\n    Sound.pause = function pause() {\n      // TODO: actually implement pausing and unpausing - just putting this here as a reminder that suspend exists.\n      Sound.context.suspend()\n    };\n    createClass(Sound, null, [{\n      key: \"context\",\n      get: function get() {\n        if (!Sound._context) {\n          var ctxClass = window.AudioContext || window.webkitAudioContext;\n          Sound._context = new ctxClass\n        }\n        return Sound._context\n      }\n    }, {\n      key: \"_rootGroup\",\n      get: function get() {\n        if (!Sound.__rootGroup) {\n          Sound.__rootGroup = new Group(null);\n          Sound.__rootGroup.outputNode.connect(Sound.context.destination)\n        }\n        return Sound.__rootGroup\n      }\n    }]);\n    return Sound\n  }();\n  var Playback = function Playback(audioBuffer) {\n    var playImmediately = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    classCallCheck(this, Playback);\n    var ctx = Sound.context;\n    this.outputNode = this.volumeNode = ctx.createGain();\n    this.fxBus = ctx.createGain();\n    this.fxBus.connect(this.outputNode);\n    this._sourceNode = ctx.createBufferSource();\n    this._sourceNode.buffer = audioBuffer;\n    this._sourceNode.connect(this.outputNode);\n    playImmediately && this._sourceNode.start(0)\n  };\n  /**\n   * The Sound JavaScript library manages the playback of audio on the web. It works via plugins which abstract the actual audio\n   * implementation, so playback is possible on any platform without specific knowledge of what mechanisms are necessary\n   * to play sounds.\n   *\n   * To use SoundJS, use the public API on the {{#crossLink \"Sound\"}}{{/crossLink}} class. This API is for:\n   * <ul>\n   *      <li>Installing audio playback Plugins</li>\n   *      <li>Registering (and preloading) sounds</li>\n   *      <li>Creating and playing sounds</li>\n   *      <li>Master volume, mute, and stop controls for all sounds at once</li>\n   * </ul>\n   *\n   * <b>Controlling Sounds</b><br />\n   * Playing sounds creates {{#crossLink \"AbstractSoundInstance\"}}{{/crossLink}} instances, which can be controlled\n   * individually.\n   * <ul>\n   *      <li>Pause, resume, seek, and stop sounds</li>\n   *      <li>Control a sound's volume, mute, and pan</li>\n   *      <li>Listen for events on sound instances to get notified when they finish, loop, or fail</li>\n   * </ul>\n   *\n   * <h4>Example</h4>\n   *\n   *      createjs.Sound.alternateExtensions = [\"mp3\"];\n   *      createjs.Sound.on(\"fileload\", this.loadHandler, this);\n   *      createjs.Sound.registerSound(\"path/to/mySound.ogg\", \"sound\");\n   *      function loadHandler(event) {\n   *          // This is fired for each sound that is registered.\n   *          var instance = createjs.Sound.play(\"sound\");  // play using id.  Could also use full sourcepath or event.src.\n   *          instance.on(\"complete\", this.handleComplete, this);\n   *          instance.volume = 0.5;\n   *      }\n   *\n   * <h4>Browser Support</h4>\n   * Audio will work in browsers which support Web Audio (<a href=\"http://caniuse.com/audio-api\" target=\"_blank\">http://caniuse.com/audio-api</a>)\n   * or HTMLAudioElement (<a href=\"http://caniuse.com/audio\" target=\"_blank\">http://caniuse.com/audio</a>).\n   * A Flash fallback can be used for any browser that supports the Flash player, and the Cordova plugin can be used in\n   * any webview that supports <a href=\"http://plugins.cordova.io/#/package/org.apache.cordova.media\" target=\"_blank\">Cordova.Media</a>.\n   * IE8 and earlier are not supported, even with the Flash fallback. To support earlier browsers, you can use an older\n   * version of SoundJS (version 0.5.2 and earlier).\n   *\n   * @main SoundJS\n   */\n  // re-export shared classes\n  // export { default as Group } from  \"./Sample\"\n  // TODO: Review this version export.\n  // version (templated in gulpfile, pulled from package).\n  (window.createjs = window.createjs || {}).soundjs = \"2.0.0\";\n  exports.EventDispatcher = EventDispatcher;\n  exports.Event = Event;\n  exports.Ticker = Ticker;\n  exports.Playback = Playback;\n  exports.Sample = Sample;\n  exports.Group = Group;\n  exports.Sound = Sound;\n  return exports\n}({});"],"file":"sound-NEXT.js"}